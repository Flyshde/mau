# Mau

ä¸€ä¸ªå¼ºå¤§çš„ Rust è¿‡ç¨‹å®åº“ï¼Œæä¾›è®°å¿†åŒ–ï¼ˆmemoizationï¼‰åŠŸèƒ½å’Œé«˜æ•ˆçš„èŒƒå›´æ“ä½œå®ã€‚

## åŠŸèƒ½ç‰¹æ€§

- âœ… **è‡ªåŠ¨è®°å¿†åŒ–**: `#[memo]` å±æ€§å®ï¼Œæ™ºèƒ½ç¼“å­˜ç®¡ç†
- âœ… **æ™ºèƒ½æ¸…ç†**: `solve!` å®ï¼Œè‡ªåŠ¨æ¸…ç©ºç¼“å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼
- âœ… **ç”Ÿå‘½å‘¨æœŸæ§åˆ¶**: `lifetime` å‚æ•°ï¼Œç²¾ç¡®æ§åˆ¶ç¼“å­˜ä¿ç•™ç­–ç•¥
- âœ… **æ™ºèƒ½ç¼“å­˜é”®**: ä¸‰ç§é”®æ¨¡å¼ï¼ˆ`ptr`ã€`ref`ã€`val`ï¼‰ï¼Œå¹³è¡¡æ€§èƒ½å’ŒåŠŸèƒ½
- âœ… **çº¿ç¨‹æ¨¡å¼**: å•çº¿ç¨‹ï¼ˆ`single`ï¼‰å’Œå¤šçº¿ç¨‹ï¼ˆ`multi`ï¼‰æ”¯æŒ
- âœ… **èŒƒå›´å®**: `min!`ã€`max!`ã€`sum!`ã€`and!`ã€`or!`ã€`reduce!`ã€`fold!` ç­‰é«˜æ•ˆå®
- âœ… **çµæ´»è¯­æ³•**: æ”¯æŒå¤šå‚æ•°ã€æ•°ç»„ã€èŒƒå›´ç­‰å¤šç§è°ƒç”¨æ–¹å¼
- âœ… **ç©ºè¿­ä»£å™¨å¤„ç†**: `min!` å’Œ `max!` å¯¹ç©ºè¿­ä»£å™¨è¿”å›è¾¹ç•Œå€¼

## å®‰è£…

```toml
[dependencies]
mau = "0.1.15"
```

## å¿«é€Ÿå¼€å§‹

### 1. åŸºç¡€è®°å¿†åŒ–

```rust
use mau::memo;

#[memo]
fn fibonacci(n: u64) -> u64 {
    match n {
        0 | 1 => n,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn main() {
    println!("fibonacci(40) = {}", fibonacci(40)); // æå¿«ï¼
}
```

**æ€§èƒ½æå‡**ï¼š
- ä¸ä½¿ç”¨ memoï¼š~1 ç§’
- ä½¿ç”¨ memoï¼š~0.01 æ¯«ç§’
- **æ€§èƒ½æå‡ï¼š100,000 å€ï¼**

### 2. æ™ºèƒ½æ¸…ç†ç¼“å­˜

```rust
use mau::{memo, solve};

#[memo]
fn compute(n: i32) -> i32 {
    // å¤æ‚è®¡ç®—
    n * n * n
}

fn main() {
    // ä½¿ç”¨ solve! å®ï¼Œè‡ªåŠ¨æ¸…ç©ºç¼“å­˜
    let result = solve!(compute(100));
    println!("ç»“æœ: {}", result);
    // è°ƒç”¨ç»“æŸï¼Œç¼“å­˜å·²æ¸…ç©ºï¼Œé¿å…å†…å­˜æ³„æ¼
}
```

### 3. èŒƒå›´å®

```rust
use mau::{min, max, sum, fold};

fn main() {
    let data = vec![3, 1, 4, 1, 5, 9, 2, 6];
    
    // å¤šç§è¯­æ³•æ”¯æŒ
    println!("æœ€å°å€¼: {}", min!(data));        // æ•°ç»„è¯­æ³•ï¼š1
    println!("æœ€å°å€¼: {}", min!(1, 2, 3));     // å¤šå‚æ•°è¯­æ³•ï¼š1
    println!("æœ€å¤§å€¼: {}", max!(data));        // 9
    println!("æ€»å’Œ: {}", sum!(data));          // 31
    
    // èŒƒå›´è¯­æ³•
    println!("éƒ¨åˆ†æœ€å°: {}", min!(|i| data[i], 2..5));  // 1
    
    // fold ç´¯ç§¯æ“ä½œ
    let product = fold!(1, |i| data[i], 0..data.len(), |acc, val| acc * val);
    println!("ä¹˜ç§¯: {}", product);  // 51840
    
    // ç©ºè¿­ä»£å™¨è¿”å›è¾¹ç•Œå€¼
    let empty: Vec<i32> = vec![];
    println!("ç©ºæ•°ç»„çš„æœ€å°å€¼: {}", min!(empty));  // i32::MAX
}
```

## æ ¸å¿ƒåŠŸèƒ½è¯¦è§£

### `#[memo]` - è‡ªåŠ¨è®°å¿†åŒ–

ä¸ºå‡½æ•°æ·»åŠ è®°å¿†åŒ–ï¼Œè‡ªåŠ¨ç¼“å­˜è®¡ç®—ç»“æœï¼š

```rust
#[memo]
fn fibonacci(n: usize) -> usize {
    if n <= 1 { n } else { fibonacci(n - 1) + fibonacci(n - 2) }
}

fn main() {
    // ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼šè®¡ç®—å¹¶ç¼“å­˜
    let r1 = fibonacci(10);  // è®¡ç®—
    
    // ç¬¬äºŒæ¬¡è°ƒç”¨ï¼šç›´æ¥ä»ç¼“å­˜è¿”å›
    let r2 = fibonacci(10);  // å‘½ä¸­ç¼“å­˜ï¼Œæå¿«
    
    // åˆ©ç”¨å·²æœ‰ç¼“å­˜è®¡ç®—æ–°å€¼
    let r3 = fibonacci(11);  // åˆ©ç”¨ fibonacci(10) å’Œ fibonacci(9) çš„ç¼“å­˜
}
```

**ç”Ÿæˆçš„è¾…åŠ©å‡½æ•°**ï¼š

```rust
#[memo]
fn fibonacci(n: usize) -> usize {
    // ...
}

// è‡ªåŠ¨ç”Ÿæˆï¼š
// - fibonacci_start(n) : è°ƒç”¨å¹¶æ¸…ç©ºç¼“å­˜
// - fibonacci_clear()  : æ‰‹åŠ¨æ¸…ç©ºç¼“å­˜
```

### `solve!` å® - æ™ºèƒ½æ¸…ç†

è‡ªåŠ¨æ¸…ç©ºç¼“å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼ï¼š

```rust
use mau::{memo, solve};

#[memo]
fn is_even(n: usize) -> bool {
    match n {
        0 => true,
        _ => is_odd(n - 1),
    }
}

#[memo]
fn is_odd(n: usize) -> bool {
    match n {
        0 => false,
        _ => is_even(n - 1),
    }
}

fn main() {
    // ç®€æ´è¯­æ³•ï¼šè°ƒç”¨å¹¶è‡ªåŠ¨æ¸…ç†ç¼“å­˜
    let result = solve!(is_even(100));
    
    // æ”¯æŒå¤æ‚è¡¨è¾¾å¼
    let (r1, r2) = solve!((is_even(50), is_odd(51)));
    
    // æ”¯æŒä»£ç å—
    let result = solve!({
        let a = is_even(10);
        let b = is_even(20);
        a && b
    });
    
    // åµŒå¥—è°ƒç”¨ï¼ˆè‡ªåŠ¨é€’å½’æ›¿æ¢ï¼‰
    let result = solve!(is_even(is_odd(5) as usize * 10));
}
```

**ä½•æ—¶ä½¿ç”¨ `solve!`**ï¼š

âœ… **åº”è¯¥ä½¿ç”¨**ï¼š
- å•æ¬¡è°ƒç”¨ä¸­æœ‰å¤§é‡é€’å½’ï¼ˆå¦‚åŠ¨æ€è§„åˆ’ï¼‰
- å‚æ•°èŒƒå›´å¾ˆå¤§ï¼Œä¸éœ€è¦è·¨è°ƒç”¨ç¼“å­˜
- éœ€è¦æ§åˆ¶å†…å­˜ä½¿ç”¨

âŒ **ä¸åº”è¯¥ä½¿ç”¨**ï¼š
- éœ€è¦é•¿æœŸä¿ç•™ç¼“å­˜ï¼ˆè·¨å¤šæ¬¡è°ƒç”¨ï¼‰
- å‚æ•°ç»å¸¸é‡å¤ï¼Œç¼“å­˜å‘½ä¸­ç‡é«˜

### æ‰‹åŠ¨æ¸…ç†ç¼“å­˜

```rust
#[memo]
fn compute(n: i32) -> i32 {
    n * n * n
}

fn main() {
    // æ–¹å¼ 1: ä½¿ç”¨ start! è‡ªåŠ¨æ¸…ç†
    solve!(compute(100));
    
    // æ–¹å¼ 2: æ‰‹åŠ¨æ¸…ç†
    compute(100);
    compute_clear();  // æ‰‹åŠ¨æ¸…ç©ºç¼“å­˜
}
```

### å‚æ•°é…ç½®

**çº¿ç¨‹æ¨¡å¼ï¼ˆ`thread`ï¼‰**ï¼š
- `single`ï¼ˆé»˜è®¤ï¼‰ï¼šå•çº¿ç¨‹ï¼Œæ€§èƒ½æœ€ä½³
- `multi`ï¼šå¤šçº¿ç¨‹å®‰å…¨ï¼Œå…¨å±€å…±äº«

**é”®æ¨¡å¼ï¼ˆ`key`ï¼‰**ï¼š
- `ptr`ï¼ˆé»˜è®¤ï¼‰ï¼šåœ°å€+é•¿åº¦ï¼Œæœ€å¿«
- `ref`ï¼šå…ˆæ¯”åœ°å€+é•¿åº¦ï¼Œå†æ¯”å†…å®¹ï¼Œå¹³è¡¡æ€§èƒ½
- `val`ï¼šæ·±åº¦æ¯”è¾ƒï¼ŒåŠŸèƒ½æœ€å®Œæ•´

**ç”Ÿå‘½å‘¨æœŸæ¨¡å¼ï¼ˆ`lifetime`ï¼‰**ï¼š
- `problem`ï¼ˆé»˜è®¤ï¼‰ï¼šæ¯æ¬¡ `_start()` è°ƒç”¨åæ¸…é™¤ç¼“å­˜
- `program`ï¼šä¿ç•™ç¼“å­˜ç›´åˆ°ç¨‹åºç»“æŸï¼ˆä»…åœ¨é”®ä¸åŒ…å«åœ°å€æ—¶æœ‰æ•ˆï¼‰

#### ä½¿ç”¨è¯­æ³•

```rust
// ä½¿ç”¨é»˜è®¤é…ç½®
#[memo]
fn calc(n: i32) -> i32 { n * n }

// å‘½åå‚æ•°ï¼ˆæ¨èï¼‰
#[memo(thread=single, key=ref)]
#[memo(thread=multi, key=ptr)]
#[memo(key=val, lifetime=problem)]
#[memo(key=val, lifetime=program)]  // é•¿æœŸä¿ç•™ç¼“å­˜ï¼ˆéœ€è¦ key=valï¼‰
```

### é”®æ¨¡å¼è¯¦è§£

#### ptr æ¨¡å¼ - æœ€å¿«ï¼Œåœ°å€+é•¿åº¦

```rust
#[memo(key=ptr)]
fn process(data: &[i32]) -> i32 {
    data.iter().sum()
}

// ç¤ºä¾‹ï¼š
let arr = vec![1, 2, 3];
process(&arr);  // ç¬¬1æ¬¡ï¼šè®¡ç®—
process(&arr);  // ç¬¬2æ¬¡ï¼šå‘½ä¸­ âœ“ï¼ˆç›¸åŒåœ°å€+é•¿åº¦ï¼‰

let arr2 = vec![1, 2, 3];  // å†…å®¹ç›¸åŒï¼Œåœ°å€ä¸åŒ
process(&arr2);  // ç¬¬3æ¬¡ï¼šé‡æ–°è®¡ç®—ï¼ˆåœ°å€ä¸åŒï¼‰

// åˆ‡ç‰‡é•¿åº¦ä¸åŒ
process(&arr[..2]);  // ç¬¬4æ¬¡ï¼šé‡æ–°è®¡ç®—ï¼ˆé•¿åº¦ä¸åŒï¼‰
```

**ç¼“å­˜é”®**ï¼š`(åœ°å€, é•¿åº¦)`
**ä½•æ—¶ä½¿ç”¨**ï¼šç›¸åŒå¼•ç”¨ä¼šåå¤è°ƒç”¨ï¼ˆå¦‚é€’å½’ä¸­ä¼ é€’åŒä¸€ä¸ªæ•°ç»„ï¼‰

#### ref æ¨¡å¼ï¼Œå…ˆæ¯”åœ°å€+é•¿åº¦ï¼Œå†æ¯”å†…å®¹

```rust
#[memo(key=ref)]  // æˆ– #[memo]
fn process(data: &[i32]) -> i32 {
    data.iter().sum()
}

// ç¤ºä¾‹ï¼š
let arr = vec![1, 2, 3];
process(&arr);  // ç¬¬1æ¬¡ï¼šè®¡ç®—
process(&arr);  // ç¬¬2æ¬¡ï¼šå‘½ä¸­ âœ“ï¼ˆåœ°å€+é•¿åº¦ç›¸ç­‰ï¼‰

let arr2 = vec![1, 2, 3];  // å†…å®¹ç›¸åŒï¼Œåœ°å€ä¸åŒ
process(&arr2);  // ç¬¬3æ¬¡ï¼šå‘½ä¸­ âœ“ï¼ˆåœ°å€ä¸ç­‰ï¼Œä½†å†…å®¹ç›¸ç­‰ï¼‰

let arr3 = vec![4, 5, 6];  // å†…å®¹ä¸åŒ
process(&arr3);  // ç¬¬4æ¬¡ï¼šé‡æ–°è®¡ç®—ï¼ˆå†…å®¹ä¸ç­‰ï¼‰

// åˆ‡ç‰‡é•¿åº¦ä¸åŒ
process(&arr[..2]);  // ç¬¬5æ¬¡ï¼šé‡æ–°è®¡ç®—ï¼ˆé•¿åº¦ä¸åŒï¼‰
```

**å·¥ä½œåŸç†**ï¼š
1. **å¿«é€Ÿè·¯å¾„**ï¼šæ¯”è¾ƒ `(åœ°å€, é•¿åº¦)`ï¼Œç›¸ç­‰åˆ™å‘½ä¸­
2. **æ…¢é€Ÿè·¯å¾„**ï¼šåœ°å€æˆ–é•¿åº¦ä¸ç­‰æ—¶ï¼Œæ¯”è¾ƒå†…å®¹

**ä½•æ—¶ä½¿ç”¨**ï¼šå¤§éƒ¨åˆ†æƒ…å†µçš„æœ€ä½³é€‰æ‹©

#### val æ¨¡å¼ - åŠŸèƒ½æœ€å®Œæ•´ï¼Œæ·±åº¦æ¯”è¾ƒ

```rust
#[memo(key=val)]
fn process(matrix: &[Vec<i32>]) -> i32 {
    matrix.iter().map(|row| row.iter().sum::<i32>()).sum()
}
```

**ä½•æ—¶ä½¿ç”¨**ï¼šå¤æ‚åµŒå¥—ç±»å‹ï¼Œéœ€è¦æ·±åº¦æ¯”è¾ƒ

#### ä¸‰ç§æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | æ¯”è¾ƒæ–¹å¼ | ç›¸åŒåœ°å€+é•¿åº¦ | ä¸åŒåœ°å€+ç›¸åŒå†…å®¹ | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|------|---------|---------------|------------------|------|---------|
| `ptr` | åœ°å€+é•¿åº¦ | âš¡æå¿« | âŒä¸å‘½ä¸­ | æœ€å¿« | ä¸€èˆ¬æƒ…å†µï¼ˆé»˜è®¤ï¼‰ |
| `ref` | å…ˆæ¯”åœ°å€+é•¿åº¦ï¼Œè‹¥ç›¸ç­‰åˆ™å‘½ä¸­ï¼›å¦åˆ™æ¯”å†…å®¹ | âš¡å¿« | âœ…å‘½ä¸­ | å¿« | å†…å®¹å¯èƒ½é‡å¤ |
| `val` | æ·±åº¦æ¯”è¾ƒ | æ…¢ | âœ…å‘½ä¸­ | æ…¢ | å¤æ‚åµŒå¥—ç±»å‹ |

### ç”Ÿå‘½å‘¨æœŸæ¨¡å¼è¯¦è§£

`lifetime` å‚æ•°æ§åˆ¶ç¼“å­˜ä½•æ—¶è¢«æ¸…é™¤ï¼Œè¿™å¯¹å†…å­˜ç®¡ç†è‡³å…³é‡è¦ã€‚

#### problem æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰- é—®é¢˜çº§åˆ«ç¼“å­˜

```rust
#[memo(lifetime=problem)]  // æˆ– #[memo]
fn solve_subproblem(data: &[i32]) -> i32 {
    data.iter().sum()
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // ä½¿ç”¨ solve! æˆ– _start()ï¼Œè°ƒç”¨åè‡ªåŠ¨æ¸…é™¤ç¼“å­˜
    let result = solve!(solve_subproblem(&data));
    // ç¼“å­˜å·²æ¸…é™¤ï¼Œä¸å ç”¨å†…å­˜
}
```

**ä½•æ—¶ä½¿ç”¨**ï¼š
- âœ… å•æ¬¡é—®é¢˜æ±‚è§£ï¼ˆå¦‚ OJ é¢˜ç›®ã€ä¸€æ¬¡æ€§è®¡ç®—ï¼‰
- âœ… éœ€è¦æ§åˆ¶å†…å­˜ä½¿ç”¨
- âœ… å‚æ•°èŒƒå›´å¾ˆå¤§ï¼Œä¸éœ€è¦è·¨é—®é¢˜å¤ç”¨

#### program æ¨¡å¼ - ç¨‹åºçº§åˆ«ç¼“å­˜

```rust
#[memo(key=val, lifetime=program)]
fn expensive_calculation(n: i32, m: i32) -> i32 {
    // å¤æ‚è®¡ç®—...
    n * n + m * m
}

fn main() {
    // å¤šæ¬¡è°ƒç”¨ï¼Œç¼“å­˜ä¸€ç›´ä¿ç•™
    let r1 = expensive_calculation_start(3, 4);  // è®¡ç®—
    let r2 = expensive_calculation_start(3, 4);  // å‘½ä¸­ç¼“å­˜
    let r3 = expensive_calculation_start(3, 4);  // å‘½ä¸­ç¼“å­˜
    // ç¼“å­˜ä¿ç•™åˆ°ç¨‹åºç»“æŸï¼Œå¯ä»¥è·¨é—®é¢˜å¤ç”¨
}
```

**ä½•æ—¶ä½¿ç”¨**ï¼š
- âœ… é…ç½®è§£æã€æ•°æ®è®¡ç®—ç­‰éœ€è¦é•¿æœŸå¤ç”¨çš„ç»“æœ
- âœ… å¤šæ¬¡è¯·æ±‚/è°ƒç”¨ç›¸åŒå‚æ•°å€¼
- âœ… ç¼“å­˜å‘½ä¸­ç‡é«˜ï¼Œç›¸åŒè¾“å…¥ä¼šåœ¨ä¸åŒé—®é¢˜ä¸­é‡å¤å‡ºç°

#### é‡è¦ï¼šprogram æ¨¡å¼çš„ç”Ÿæ•ˆæ¡ä»¶

`lifetime=program` **åªæœ‰åœ¨ç¼“å­˜é”®ä¸åŒ…å«åœ°å€ä¿¡æ¯æ—¶æ‰ä¼šä¿ç•™ç¼“å­˜**ã€‚

| å‡½æ•°å‚æ•°ç±»å‹ | key æ¨¡å¼ | lifetime=program | æ˜¯å¦ä¿ç•™ç¼“å­˜ | åŸå›  |
|------------|---------|-----------------|------------|------|
| æœ‰å¼•ç”¨å‚æ•° (å¦‚ `&[i32]`) | `ptr` | âŒ æ¸…é™¤ | å¦ | é”®åŒ…å«åœ°å€ï¼Œæ—§åœ°å€æ— æ³•å¤ç”¨ï¼Œæµªè´¹å†…å­˜ |
| æœ‰å¼•ç”¨å‚æ•° (å¦‚ `&[i32]`) | `ref` | âŒ æ¸…é™¤ | å¦ | é”®åŒ…å«åœ°å€ï¼Œæ—§åœ°å€æ— æ³•å¤ç”¨ |
| æœ‰å¼•ç”¨å‚æ•° (å¦‚ `&[i32]`) | `val` | âœ… ä¿ç•™ | æ˜¯ | é”®åªåŸºäºå€¼ï¼Œå¯è·¨é—®é¢˜å¤ç”¨ |
| æ— å¼•ç”¨å‚æ•° (å¦‚ `i32`) | `ptr` | âœ… ä¿ç•™ | æ˜¯ | æ— å¼•ç”¨ï¼Œé”®å®Œå…¨åŸºäºå€¼ |
| æ— å¼•ç”¨å‚æ•° (å¦‚ `i32`) | `ref` | âœ… ä¿ç•™ | æ˜¯ | æ— å¼•ç”¨ï¼Œé”®å®Œå…¨åŸºäºå€¼ |
| æ— å¼•ç”¨å‚æ•° (å¦‚ `i32`) | `val` | âœ… ä¿ç•™ | æ˜¯ | é”®å®Œå…¨åŸºäºå€¼ |

**ç¤ºä¾‹è¯´æ˜**ï¼š

```rust
// âœ… ä¼šä¿ç•™ç¼“å­˜ï¼šæ— å¼•ç”¨å‚æ•°ï¼Œé”®å®Œå…¨åŸºäºå€¼
#[memo(lifetime=program)]
fn calculate(n: i32) -> i32 {
    n * n  // ç›¸åŒ n å¯è·¨é—®é¢˜å¤ç”¨ç¼“å­˜
}

// âœ… ä¼šä¿ç•™ç¼“å­˜ï¼šæœ‰å¼•ç”¨å‚æ•° + key=valï¼Œé”®åŸºäºå€¼
#[memo(key=val, lifetime=program)]
fn process_val(data: &[i32]) -> i32 {
    data.iter().sum()  // å†…å®¹ç›¸åŒçš„æ•°ç»„å¯è·¨é—®é¢˜å¤ç”¨
}

// âŒ ä¸ä¼šä¿ç•™ç¼“å­˜ï¼šæœ‰å¼•ç”¨å‚æ•° + key=ptrï¼Œé”®åŒ…å«åœ°å€
#[memo(key=ptr, lifetime=program)]
fn process_array(data: &[i32]) -> i32 {
    data.iter().sum()  // æ¯æ¬¡è°ƒç”¨ _start() åä¼šæ¸…é™¤ï¼ˆé¿å…å†…å­˜æµªè´¹ï¼‰
}

// âŒ ä¸ä¼šä¿ç•™ç¼“å­˜ï¼šæœ‰å¼•ç”¨å‚æ•° + key=refï¼Œé”®åŒ…å«åœ°å€
#[memo(key=ref, lifetime=program)]
fn process_data(data: &[i32]) -> i32 {
    data.iter().sum()  // æ¯æ¬¡è°ƒç”¨ _start() åä¼šæ¸…é™¤
}
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

**æƒ…å†µ1ï¼šé”®åŒ…å«åœ°å€ï¼ˆptr/ref æ¨¡å¼ + å¼•ç”¨å‚æ•°ï¼‰**
- æ¯ä¸ªé—®é¢˜çš„æ•°ç»„åœ°å€ä¸åŒï¼Œæ—§ç¼“å­˜æ— æ³•è¢«æ–°é—®é¢˜è®¿é—®
- ä¿ç•™ç¼“å­˜åªä¼šæµªè´¹å†…å­˜ï¼Œå› æ­¤å³ä½¿è®¾ç½® `program` ä¹Ÿä¼šæ¸…é™¤

```rust
#[memo(key=ptr, lifetime=program)]
fn solve(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

fn main() {
    // é—®é¢˜1
    let data1 = vec![1, 2, 3];  // åœ°å€ 0x1000
    solve_start(&data1);  // ç¼“å­˜é”®: (0x1000, 3) -> ç»“æœ 6
    
    // é—®é¢˜2
    let data2 = vec![1, 2, 3];  // åœ°å€ 0x2000ï¼ˆä¸åŒåœ°å€ï¼ï¼‰
    solve_start(&data2);  // ç¼“å­˜é”®: (0x2000, 3)ï¼Œæ— æ³•å‘½ä¸­æ—§ç¼“å­˜
    
    // æ—§ç¼“å­˜ (0x1000, 3) æ°¸è¿œä¸ä¼šå†è¢«è®¿é—®ï¼Œç™½ç™½å ç”¨å†…å­˜
    // æ‰€ä»¥è‡ªåŠ¨æ¸…é™¤ç¼“å­˜
}
```

**æƒ…å†µ2ï¼šé”®ä¸åŒ…å«åœ°å€ï¼ˆval æ¨¡å¼æˆ–æ— å¼•ç”¨å‚æ•°ï¼‰**
- é”®å®Œå…¨åŸºäºå€¼ï¼Œç›¸åŒè¾“å…¥å¯ä»¥è·¨é—®é¢˜å¤ç”¨
- ä¿ç•™ç¼“å­˜å¯ä»¥æé«˜æ€§èƒ½

```rust
#[memo(key=val, lifetime=program)]
fn solve(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

fn main() {
    // é—®é¢˜1
    let data1 = vec![1, 2, 3];
    solve_start(&data1);  // ç¼“å­˜é”®: [1,2,3] -> ç»“æœ 6
    
    // é—®é¢˜2ï¼šä¸åŒæ•°ç»„ï¼Œä½†å†…å®¹ç›¸åŒ
    let data2 = vec![1, 2, 3];
    solve_start(&data2);  // ç¼“å­˜é”®: [1,2,3]ï¼Œå‘½ä¸­ç¼“å­˜ï¼âœ“
    
    // ç¼“å­˜è¢«å¤ç”¨ï¼Œæé«˜æ€§èƒ½
}
```

## ä½¿ç”¨åœºæ™¯

### åœºæ™¯ 1: åŠ¨æ€è§„åˆ’ï¼ˆä½¿ç”¨ start! è‡ªåŠ¨æ¸…ç†ï¼‰

```rust
use mau::{memo, solve};

#[memo(key=ref)]
fn merge_stones(data: &[usize]) -> usize {
    match data.len() {
        0 | 1 => 0,
        _ => {
            let mut min_cost = usize::MAX;
            for i in 1..data.len() {
                let left = merge_stones(&data[..i]);
                let right = merge_stones(&data[i..]);
                let cost = left + right + data.iter().sum::<usize>();
                min_cost = min_cost.min(cost);
            }
            min_cost
        }
    }
}

fn main() {
    let stones = vec![1, 2, 3, 4, 5];
    
    // ä½¿ç”¨ start! è‡ªåŠ¨æ¸…ç†ç¼“å­˜
    let result = solve!(merge_stones(&stones));
    println!("æœ€å°æˆæœ¬: {}", result);
    // ç¼“å­˜å·²æ¸…ç©ºï¼Œä¸ä¼šå ç”¨å†…å­˜
}
```

### åœºæ™¯ 2: Web æœåŠ¡ï¼ˆé•¿æœŸç¼“å­˜ï¼‰

```rust
#[memo]
fn get_user_info(user_id: i32) -> UserInfo {
    // æ•°æ®åº“æŸ¥è¯¢
    database.query(user_id)
}

fn handle_request(user_id: i32) {
    // å¤šæ¬¡è°ƒç”¨ï¼Œåˆ©ç”¨ç¼“å­˜é¿å…é‡å¤æŸ¥è¯¢
    let info = get_user_info(user_id);
    // ç¼“å­˜ä¿ç•™ï¼Œä¸‹æ¬¡è¯·æ±‚ç›´æ¥å‘½ä¸­
}
```

### åœºæ™¯ 3: äº’ç›¸é€’å½’

```rust
use mau::{memo, solve};

#[memo]
fn is_even(n: usize) -> bool {
    if n == 0 { true } else { is_odd(n - 1) }
}

#[memo]
fn is_odd(n: usize) -> bool {
    if n == 0 { false } else { is_even(n - 1) }
}

fn main() {
    // æ–¹å¼ 1: æ™®é€šè°ƒç”¨ï¼ˆç¼“å­˜æŒç»­ï¼‰
    let r1 = is_even(100);
    let r2 = is_even(100);  // å‘½ä¸­ç¼“å­˜
    
    // æ–¹å¼ 2: ä½¿ç”¨ start! æ¸…ç†
    let r3 = solve!(is_even(100));
    // ç¼“å­˜å·²æ¸…ç©º
    
    // æ–¹å¼ 3: æ‰‹åŠ¨æ¸…ç†
    is_even_clear();
    is_odd_clear();
}
```

## èŒƒå›´å®

é«˜æ•ˆçš„èŒƒå›´èšåˆæ“ä½œï¼Œæ”¯æŒå¤šç§çµæ´»çš„è°ƒç”¨è¯­æ³•ã€‚

### å¤šç§è¯­æ³•æ”¯æŒ

```rust
use mau::{min, max, sum, and, or};

fn main() {
    let data = vec![3, 1, 4, 1, 5, 9, 2, 6];
    
    // 1. å¤šå‚æ•°è¯­æ³•ï¼ˆ2ä¸ªæˆ–æ›´å¤šå‚æ•°ï¼‰
    println!("{}", min!(1, 2));           // 1
    println!("{}", max!(1, 2, 3));        // 3
    println!("{}", sum!(1, 2, 3, 4));     // 10
    
    // 2. æ•°ç»„ç®€å†™è¯­æ³•
    println!("{}", min!(data));           // 1
    println!("{}", max!(data));           // 9
    println!("{}", sum!(data));           // 31
    
    // 3. èŒƒå›´è¯­æ³• - éƒ¨åˆ†èŒƒå›´
    println!("{}", min!(|i| data[i], 2..5));  // ç´¢å¼• 2~4 çš„æœ€å°å€¼
    
    // 4. èŒƒå›´è¯­æ³• - è¡¨è¾¾å¼
    println!("{}", min!(|i| data[i] * data[i], 0..data.len()));  // å¹³æ–¹çš„æœ€å°å€¼
    
    // 5. åŒ…å«èŒƒå›´ï¼ˆé—­åŒºé—´ï¼‰
    println!("{}", sum!(|i| data[i], 2..=4));  // ç´¢å¼• 2,3,4 çš„å’Œ
    
    // 6. è¿­ä»£å™¨è¯­æ³•
    println!("{}", min!(|x| x, data.iter()));  // 1
    
    // 7. å¸ƒå°”è¿ç®—
    let all_positive = and!(|i| data[i] > 0, 0..data.len());
    println!("æ˜¯å¦å…¨éƒ¨ä¸ºæ­£: {}", all_positive);  // true
}
```

### fold! å® - è‡ªå®šä¹‰ç´¯ç§¯æ“ä½œ

`fold!` æä¾›äº†æœ€çµæ´»çš„ç´¯ç§¯æ“ä½œï¼š

```rust
use mau::fold;
use std::collections::HashMap;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // åŸºç¡€ï¼šæ±‚å’Œï¼ˆåˆå§‹å€¼ä¸º 0ï¼‰
    let sum = fold!(0, |i| data[i], 0..data.len(), |acc, val| acc + val);
    println!("å’Œ: {}", sum);  // 15
    
    // æ±‚ç§¯ï¼ˆåˆå§‹å€¼ä¸º 1ï¼‰
    let product = fold!(1, |i| data[i], 0..data.len(), |acc, val| acc * val);
    println!("ç§¯: {}", product);  // 120
    
    // æ„å»ºå­—ç¬¦ä¸²
    let words = vec!["Hello", "World", "Rust"];
    let sentence = fold!(String::new(), |i| words[i], 0..words.len(), 
        |mut acc: String, val: &str| {
            if !acc.is_empty() { acc.push(' '); }
            acc.push_str(val);
            acc
        }
    );
    println!("{}", sentence);  // "Hello World Rust"
    
    // æ„å»º HashMap
    let keys = vec!["a", "b", "c"];
    let values = vec![1, 2, 3];
    let map = fold!(HashMap::new(), |i| (keys[i], values[i]), 0..keys.len(),
        |mut acc: HashMap<&str, i32>, (k, v)| {
            acc.insert(k, v);
            acc
        }
    );
    
    // åŒæ—¶è®¡ç®—å¤šä¸ªç»Ÿè®¡é‡ï¼ˆä½¿ç”¨å…ƒç»„ï¼‰
    let (sum, count, max) = fold!(
        (0, 0, i32::MIN), 
        |i| data[i], 
        0..data.len(),
        |(s, c, m), val| (s + val, c + 1, m.max(val))
    );
    let avg = sum / count;
    println!("å¹³å‡: {}, æœ€å¤§: {}", avg, max);
    
    // æ¡ä»¶è¿‡æ»¤ç´¯ç§¯ï¼ˆåªç´¯åŠ å¶æ•°ï¼‰
    let even_sum = fold!(0, |i| data[i], 0..data.len(), |acc, val| {
        if val % 2 == 0 { acc + val } else { acc }
    });
    println!("å¶æ•°å’Œ: {}", even_sum);  // 6 (2 + 4)
}
```

**fold! vs reduce!**ï¼š

| ç‰¹æ€§ | fold! | reduce! |
|------|-------|---------|
| åˆå§‹å€¼ | éœ€è¦æä¾› | ä½¿ç”¨ç¬¬ä¸€ä¸ªå…ƒç´  |
| ç©ºåºåˆ— | è¿”å›åˆå§‹å€¼ | panic |
| ç´¯åŠ å™¨ç±»å‹ | å¯ä¸å…ƒç´ ç±»å‹ä¸åŒ | å¿…é¡»ç›¸åŒ |
| çµæ´»æ€§ | é«˜ | ä¸­ |

```rust
use mau::{fold, reduce};

let data = vec![1, 2, 3, 4, 5];

// reduce: ä½¿ç”¨ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºåˆå§‹å€¼
let sum1 = reduce!(|i| data[i], 0..data.len(), |a, b| a + b);
// ç›¸å½“äº: 1 + 2 + 3 + 4 + 5 = 15

// fold: æä¾›åˆå§‹å€¼
let sum2 = fold!(0, |i| data[i], 0..data.len(), |acc, val| acc + val);
// ç›¸å½“äº: 0 + 1 + 2 + 3 + 4 + 5 = 15

// fold çš„ä¼˜åŠ¿ï¼šå¯ä»¥å¤„ç†ç©ºåºåˆ—
let empty: Vec<i32> = vec![];
let result = fold!(100, |i| empty[i], 0..0, |acc, val| acc + val);
println!("{}", result);  // 100ï¼ˆè¿”å›åˆå§‹å€¼ï¼‰

// reduce ä¼š panic
// let result = reduce!(|i| empty[i], 0..0, |a, b| a + b);  // panic!
```

### ç©ºè¿­ä»£å™¨å¤„ç†

```rust
let empty: Vec<i32> = vec![];

// min! è¿”å›ç±»å‹çš„ MAX å€¼
println!("{}", min!(empty));  // i32::MAX = 2147483647

// max! è¿”å›ç±»å‹çš„ MIN å€¼
println!("{}", max!(empty));  // i32::MIN = -2147483648

// sum! è¿”å› 0ï¼ˆåŠ æ³•çš„å•ä½å…ƒï¼‰
let empty_sum: Vec<i32> = vec![];
println!("{}", sum!(empty_sum));  // 0

// æµ®ç‚¹æ•°ä¹Ÿè¿”å› 0.0
let empty_f64: Vec<f64> = vec![];
println!("{}", sum!(empty_f64));  // 0.0

// ä¸æ”¯æŒçš„ç±»å‹ä¼š panicï¼ˆä»…é’ˆå¯¹ min/maxï¼‰
let empty_str: Vec<&str> = vec![];
// min!(empty_str);  // panic: "type does not have a MAX value"
```

**æ”¯æŒçš„ç±»å‹**ï¼š
- âœ… æ•´æ•°ï¼š`i8`~`i128`ã€`u8`~`u128`ã€`isize`ã€`usize`
- âœ… æµ®ç‚¹ï¼š`f32`ã€`f64`
- âœ… å­—ç¬¦ï¼š`char`ï¼ˆä»… min/maxï¼‰
- âŒ å­—ç¬¦ä¸²ç­‰ï¼šè¿è¡Œæ—¶ panicï¼ˆä»… min/maxï¼Œsum ä¸æ”¯æŒå­—ç¬¦ä¸²ï¼‰

## è¯¦ç»†ç¤ºä¾‹

### åŠ¨æ€è§„åˆ’ï¼šèƒŒåŒ…é—®é¢˜

```rust
use mau::{memo, solve};

#[memo(key=ref)]
fn knapsack(weights: &[i32], values: &[i32], capacity: i32, n: usize) -> i32 {
    if n == 0 || capacity == 0 {
        return 0;
    }
    
    if weights[n - 1] > capacity {
        knapsack(weights, values, capacity, n - 1)
    } else {
        let include = values[n - 1] + 
            knapsack(weights, values, capacity - weights[n - 1], n - 1);
        let exclude = knapsack(weights, values, capacity, n - 1);
        include.max(exclude)
    }
}

fn main() {
    let weights = vec![10, 20, 30];
    let values = vec![60, 100, 120];
    let capacity = 50;
    
    // ä½¿ç”¨ start! è‡ªåŠ¨æ¸…ç†ç¼“å­˜
    let result = solve!(knapsack(&weights, &values, capacity, weights.len()));
    println!("æœ€å¤§ä»·å€¼: {}", result);  // 220
}
```

### å¤šå‚æ•°è®°å¿†åŒ–

```rust
use mau::memo;

#[memo(key=ref)]
fn edit_distance(s1: &String, s2: &String, m: usize, n: usize) -> usize {
    if m == 0 { return n; }
    if n == 0 { return m; }
    
    if s1.chars().nth(m - 1) == s2.chars().nth(n - 1) {
        edit_distance(s1, s2, m - 1, n - 1)
    } else {
        1 + [
            edit_distance(s1, s2, m - 1, n),
            edit_distance(s1, s2, m, n - 1),
            edit_distance(s1, s2, m - 1, n - 1),
        ].iter().min().unwrap()
    }
}

fn main() {
    let s1 = "kitten".to_string();
    let s2 = "sitting".to_string();
    let dist = edit_distance(&s1, &s2, s1.len(), s2.len());
    println!("ç¼–è¾‘è·ç¦»: {}", dist);  // 3
}
```

### èŒƒå›´å®é«˜çº§ç”¨æ³•

#### è‡ªå®šä¹‰å½’çº¦

```rust
use mau::reduce;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // æ‰¾æœ€å¤§å€¼
    let max = reduce!(|i| data[i], 0..data.len(), |a, b| a.max(b));
    
    // å­—ç¬¦ä¸²è¿æ¥
    let words = vec!["Hello", " ", "World"];
    let text = reduce!(
        |i| words[i].to_string(),
        0..words.len(),
        |a, b| a + &b
    );
    println!("{}", text);  // "Hello World"
}
```

#### çŸ­è·¯ä¼˜åŒ–

```rust
use mau::{and, or};

fn expensive_check(x: i32) -> bool {
    println!("æ£€æŸ¥ {}", x);
    x > 0
}

fn main() {
    let data = vec![1, 2, -3, 4, 5];
    
    // and! é‡åˆ°ç¬¬ä¸€ä¸ª false å°±åœæ­¢
    let all_positive = and!(|i| expensive_check(data[i]), 0..data.len());
    // è¾“å‡ºï¼š
    // æ£€æŸ¥ 1
    // æ£€æŸ¥ 2  
    // æ£€æŸ¥ -3  <- åœæ­¢ï¼Œä¸å†æ£€æŸ¥åç»­å…ƒç´ 
    
    println!("å…¨éƒ¨ä¸ºæ­£: {}", all_positive);  // false
}
```

## æ€§èƒ½æ•°æ®

### è®°å¿†åŒ–æ€§èƒ½æå‡

| ç®—æ³• | è§„æ¨¡ | ä¸ä½¿ç”¨ memo | ä½¿ç”¨ memo | æå‡å€æ•° |
|------|------|-------------|-----------|---------|
| Fibonacci | n=30 | 10 ms | 0.01 ms | 1,000x |
| Fibonacci | n=40 | 1000 ms | 0.01 ms | 100,000x |
| Fibonacci | n=50 | >60ç§’ | 0.01 ms | >6,000,000x |
| LCS | é•¿åº¦50 | 10ç§’ | 0.1ç§’ | 100x |
| èƒŒåŒ…é—®é¢˜ | 50é¡¹ | 5ç§’ | 0.05ç§’ | 100x |

### é”®æ¨¡å¼æ€§èƒ½å¯¹æ¯”

æµ‹è¯•ï¼š10,000 æ¬¡è°ƒç”¨ï¼Œç¼“å­˜å·²é¢„çƒ­

| æ¨¡å¼ | æ—¶é—´ | ç›¸å¯¹æ€§èƒ½ |
|------|------|---------|
| `ptr` | 1.2 ms | 100% |
| `ref` | 1.5 ms | 80% |
| `val` | 3.4 ms | 35% |

## ä½¿ç”¨å»ºè®®

### ä½•æ—¶ä½¿ç”¨è®°å¿†åŒ–

âœ… **åº”è¯¥ä½¿ç”¨**ï¼š
- é€’å½’å‡½æ•°æœ‰é‡å¤å­é—®é¢˜
- åŠ¨æ€è§„åˆ’ç®—æ³•
- è®¡ç®—ä»£ä»·é«˜ä½†å‚æ•°ç»å¸¸é‡å¤
- çº¯å‡½æ•°ï¼ˆæ— å‰¯ä½œç”¨ï¼‰

âŒ **ä¸åº”è¯¥ä½¿ç”¨**ï¼š
- å‡½æ•°æœ‰å‰¯ä½œç”¨ï¼ˆI/Oã€æ‰“å°ç­‰ï¼‰
- å‚æ•°å‡ ä¹ä¸é‡å¤
- è®¡ç®—éå¸¸ç®€å•

### é”®æ¨¡å¼é€‰æ‹©ç­–ç•¥

```rust
// åœºæ™¯1ï¼šé€’å½’ä¸­ä¼ é€’åŒä¸€ä¸ªå¼•ç”¨
#[memo(key=ptr)]
fn recursive(data: &[i32], index: usize) -> i32 {
    if index >= data.len() { return 0; }
    data[index] + recursive(data, index + 1)  // åŒä¸€ä¸ª data
}

// åœºæ™¯2ï¼šä¸åŒè°ƒç”¨ä½†å‚æ•°å¯èƒ½ç›¸åŒï¼ˆå†…å®¹å¯èƒ½é‡å¤ï¼‰
#[memo(key=ref)]
fn process(data: &[i32]) -> i32 {
    data.iter().sum()
}

// åœºæ™¯3ï¼šå¤æ‚åµŒå¥—ç±»å‹
#[memo(key=val)]
fn matrix_calc(matrix: &[Vec<Vec<i32>>]) -> i32 {
    // æ·±åº¦æ¯”è¾ƒ
    0
}
```

## æ³¨æ„äº‹é¡¹

### 1. é¿å…å‰¯ä½œç”¨

```rust
// âŒ é”™è¯¯ï¼šæœ‰å‰¯ä½œç”¨
#[memo]
fn bad_example(n: i32) -> i32 {
    println!("è®¡ç®— {}", n);  // ç¼“å­˜å‘½ä¸­æ—¶ä¸ä¼šæ‰“å°ï¼
    n * 2
}

// âœ… æ­£ç¡®ï¼šçº¯å‡½æ•°
#[memo]
fn good_example(n: i32) -> i32 {
    n * 2
}
```

### 2. å‚æ•°è®¾è®¡

```rust
// âŒ é”™è¯¯ï¼šæ— å…³å‚æ•°å¯¼è‡´ç¼“å­˜å¤±æ•ˆ
#[memo]
fn bad_design(n: i32, timestamp: u64) -> i32 {
    n * 2  // timestamp ä¸å½±å“ç»“æœï¼Œä½†ä¼šå¯¼è‡´ç¼“å­˜å¤±æ•ˆ
}

// âœ… æ­£ç¡®ï¼šåªåŒ…å«å¿…è¦å‚æ•°
#[memo]
fn good_design(n: i32) -> i32 {
    n * 2
}
```

### 3. å†…å­˜ç›‘æ§

```rust
#[memo]
fn compute(n: i32) -> i32 {
    n * n * n
}

fn main() {
    // æ–¹å¼ 1: æ¯æ¬¡æ¸…ç†
    for i in 0..10000 {
        solve!(compute(i));  // è‡ªåŠ¨æ¸…ç†
    }
    
    // æ–¹å¼ 2: æ‰¹é‡æ¸…ç†
    for i in 0..10000 {
        compute(i);
    }
    compute_clear();  // æ‰‹åŠ¨æ¸…ç†
}
```

### 4. f64 ç±»å‹å¤„ç†

```rust
// âŒ f64 ä¸å®ç° Hash å’Œ Eq
// #[memo]
// fn calc(x: f64) -> f64 { x * x }  // ç¼–è¯‘é”™è¯¯

// âœ… ä½¿ç”¨å¼•ç”¨ï¼ˆè‡ªåŠ¨è½¬æ¢ä¸º u64ï¼‰
#[memo(key=ref)]
fn calc(x: &f64) -> f64 { x * x }

// âœ… æˆ–ä½¿ç”¨ val æ¨¡å¼
#[memo(key=val)]
fn calc_array(data: &[f64]) -> f64 {
    data.iter().sum()
}
```

## å‚æ•°é€ŸæŸ¥è¡¨

### `#[memo]` å‚æ•°

```rust
#[memo]                                    // é»˜è®¤ï¼šthread=single, key=ptr, lifetime=problem
#[memo(thread=single, key=ref)]            // å‘½åå‚æ•°
#[memo(thread=multi, key=ptr)]             // å¤šçº¿ç¨‹ + åœ°å€é”®
#[memo(key=val)]                           // åªæŒ‡å®š key
#[memo(key=val, lifetime=program)]         // é•¿æœŸä¿ç•™ç¼“å­˜ï¼ˆéœ€è¦ key=valï¼‰
#[memo(thread=multi, key=val, lifetime=program)]  // å®Œæ•´æŒ‡å®š
```

### `solve!` å®è¯­æ³•

```rust
solve!(func(args))                   // å•ä¸ªå‡½æ•°è°ƒç”¨
solve!((func1(a), func2(b)))        // å¤šä¸ªè°ƒç”¨ï¼ˆå…ƒç»„ï¼‰
solve!({ let a = f(); a + 1 })      // ä»£ç å—
solve!(f(g(h(x))))                   // åµŒå¥—è°ƒç”¨ï¼ˆè‡ªåŠ¨é€’å½’æ›¿æ¢ï¼‰
```

### èŒƒå›´å®è¯­æ³•

```rust
// min, max, sum, and, or
min!(1, 2)                           // ä¸¤å‚æ•°ï¼ˆæ–°å¢æ”¯æŒï¼‰
min!(1, 2, 3)                        // å¤šå‚æ•°
min!(array)                          // æ•´ä¸ªæ•°ç»„
min!(|i| array[i], 0..10)           // èŒƒå›´è¡¨è¾¾å¼
min!(|i| array[i] * 2, 0..=9)       // åŒ…å«èŒƒå›´ï¼ˆé—­åŒºé—´ï¼‰
min!(|x| x, array.iter())           // è¿­ä»£å™¨

// reduce - è‡ªå®šä¹‰å½’çº¦
reduce!(|i| data[i], 0..n, |a, b| a.max(b))

// fold - å¸¦åˆå§‹å€¼çš„ç´¯ç§¯
fold!(init_val, |i| data[i], 0..n, |acc, val| acc + val)
```

## å¸¸è§é—®é¢˜

### Q1: ref æ¨¡å¼æ¯” ptr æ…¢å¤šå°‘ï¼Ÿ

**A**: åœ¨ç¼“å­˜å·²é¢„çƒ­çš„æƒ…å†µä¸‹ï¼Œ`ref` æ¨¡å¼çº¦ä¸º `ptr` æ¨¡å¼çš„ 80% æ€§èƒ½ã€‚ä½† `ref` æ¨¡å¼åŠŸèƒ½æ›´å¼ºï¼ˆå†…å®¹ç›¸åŒå°±å‘½ä¸­ï¼‰ï¼Œæ˜¯å¤§å¤šæ•°æƒ…å†µçš„æœ€ä½³é€‰æ‹©ã€‚

### Q2: ä¸ºä»€ä¹ˆ ref æ¨¡å¼éœ€è¦æ¯”è¾ƒåœ°å€å’Œé•¿åº¦ï¼Ÿ

**A**: é¿å…ç›¸åŒåœ°å€ä¸åŒé•¿åº¦çš„é”™è¯¯å‘½ä¸­ï¼š

```rust
let data = vec![1, 2, 3, 4, 5];
&data[..2]  // addr = data.as_ptr(), len = 2
&data[..5]  // addr = data.as_ptr(), len = 5  â† åœ°å€ç›¸åŒï¼

// å¦‚æœåªæ¯”åœ°å€ï¼Œä¼šé”™è¯¯åœ°è®¤ä¸ºè¿™ä¸¤ä¸ªåˆ‡ç‰‡ç›¸åŒ
// åŒæ—¶æ¯”è¾ƒåœ°å€å’Œé•¿åº¦åï¼š(addr1, len1) != (addr2, len2)
```

### Q3: ç©ºè¿­ä»£å™¨ä¸ºä»€ä¹ˆè¿”å›è¾¹ç•Œå€¼ï¼Ÿ

**A**: ç¬¦åˆæ•°å­¦å®šä¹‰ï¼š
- `min(ç©ºé›†) = +âˆ` â†’ è¿”å› `MAX`
- `max(ç©ºé›†) = -âˆ` â†’ è¿”å› `MIN`

è¿™æ ·å¯ä»¥é¿å… panicï¼Œæä¾›æ›´å¥½çš„é»˜è®¤è¡Œä¸ºã€‚

### Q4: å¦‚ä½•å¤„ç† f64 ç±»å‹ï¼Ÿ

**A**: ä½¿ç”¨å¼•ç”¨å‚æ•°ï¼Œå®ä¼šè‡ªåŠ¨è½¬æ¢ï¼š

```rust
#[memo(key=ref)]
fn calc(x: &f64) -> f64 {
    x * x
}

#[memo(key=ref)]
fn sum_floats(data: &[f64]) -> f64 {
    data.iter().sum()
}
```

### Q5: ä¸ºä»€ä¹ˆæˆ‘è®¾ç½®äº† `lifetime=program` ä½†ç¼“å­˜è¿˜æ˜¯è¢«æ¸…é™¤ï¼Ÿ

**A**: `lifetime=program` åªåœ¨é”®ä¸­**ä¸åŒ…å«**åœ°å€ä¿¡æ¯æ—¶æ‰ç”Ÿæ•ˆã€‚æ£€æŸ¥ï¼š

1. **å‡½æ•°æ˜¯å¦æœ‰å¼•ç”¨å‚æ•°ä¸”ä½¿ç”¨äº† `key=ptr` æˆ– `key=ref`ï¼Ÿ**
   ```rust
   // âŒ æœ‰å¼•ç”¨å‚æ•° + ptr/refï¼Œé”®åŒ…å«åœ°å€ï¼Œprogram æ— æ•ˆ
   #[memo(key=ptr, lifetime=program)]
   fn process(data: &[i32]) -> i32 { data.iter().sum() }
   
   // âœ… æ— å¼•ç”¨å‚æ•°ï¼Œé”®åŸºäºå€¼ï¼Œprogram æœ‰æ•ˆ
   #[memo(key=ptr, lifetime=program)]
   fn calc(n: i32) -> i32 { n * n }
   ```

2. **æ˜¯å¦ä½¿ç”¨äº† `key=val`ï¼Ÿ**
   ```rust
   // âœ… val æ¨¡å¼é”®åªåŸºäºå€¼ï¼Œprogram æœ‰æ•ˆ
   #[memo(key=val, lifetime=program)]
   fn process(data: &[i32]) -> i32 { data.iter().sum() }
   
   // âŒ ptr/ref æ¨¡å¼é”®åŒ…å«åœ°å€ï¼Œprogram æ— æ•ˆ
   #[memo(key=ptr, lifetime=program)]
   fn process(data: &[i32]) -> i32 { data.iter().sum() }
   ```

**æ€»ç»“**ï¼šåªæœ‰ **(æ— å¼•ç”¨å‚æ•°) OR (æœ‰å¼•ç”¨å‚æ•° AND key=val)** æ—¶ï¼Œ`lifetime=program` æ‰ä¼šä¿ç•™ç¼“å­˜ã€‚

### Q6: `min!(1, 2)` ä¸¤å‚æ•°è¯­æ³•ä½•æ—¶å¯ç”¨ï¼Ÿ

**A**: v0.1.12 åŠä»¥ä¸Šç‰ˆæœ¬æ”¯æŒã€‚å¦‚æœé‡åˆ°é”™è¯¯ï¼Œè¯·å‡çº§ï¼š

```toml
[dependencies]
mau = "0.1.15"  # æˆ–æ›´é«˜ç‰ˆæœ¬
```

## å®Œæ•´ç¤ºä¾‹

```rust
use mau::{memo, start, min, max, sum};

// é•¿æœŸç¼“å­˜ï¼šé…ç½®è§£æ
#[memo]
fn parse_config(path: String) -> Config {
    // è¯»å–é…ç½®æ–‡ä»¶ï¼ˆç¼“å­˜ç»“æœï¼‰
}

// ä¸´æ—¶ç¼“å­˜ï¼šåŠ¨æ€è§„åˆ’
#[memo(key=ref)]
fn longest_increasing_subsequence(arr: &[i32], i: usize) -> usize {
    if i == 0 { return 1; }
    
    let mut max_len = 1;
    for j in 0..i {
        if arr[j] < arr[i] {
            max_len = max_len.max(1 + longest_increasing_subsequence(arr, j));
        }
    }
    max_len
}

fn main() {
    // é•¿æœŸç¼“å­˜
    let config = parse_config("config.toml".to_string());
    
    // ä½¿ç”¨ start! æ¸…ç†ä¸´æ—¶ç¼“å­˜
    let data = vec![10, 9, 2, 5, 3, 7, 101, 18];
    let result = solve!({
        (0..data.len())
            .map(|i| longest_increasing_subsequence(&data, i))
            .max()
            .unwrap()
    });
    println!("æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦: {}", result);
    
    // èŒƒå›´å®
    let min_val = min!(data);
    let max_val = max!(data);
    let sum_val = sum!(data);
    println!("æœ€å°: {}, æœ€å¤§: {}, æ€»å’Œ: {}", min_val, max_val, sum_val);
}
```

## æœ€ä½³å®è·µæ€»ç»“

### è®°å¿†åŒ–é…ç½®

1. **é»˜è®¤ä½¿ç”¨ `key=ptr`**ï¼šæ€§èƒ½æœ€ä½³ï¼Œé€‚åˆå¤§å¤šæ•°åœºæ™¯
2. **å†…å®¹å¯èƒ½é‡å¤ç”¨ `key=ref`**ï¼šå…¼é¡¾æ€§èƒ½å’ŒåŠŸèƒ½
3. **å¤æ‚åµŒå¥—ç±»å‹ç”¨ `key=val`**ï¼šåŠŸèƒ½æœ€å®Œæ•´

### ç”Ÿå‘½å‘¨æœŸé€‰æ‹©

4. **å•æ¬¡è®¡ç®—ç”¨ `lifetime=problem`**ï¼ˆé»˜è®¤ï¼‰ï¼šè‡ªåŠ¨æ¸…ç†ï¼Œé¿å…å†…å­˜æ³„æ¼
5. **é•¿æœŸç¼“å­˜ç”¨ `lifetime=program`**ï¼šè·¨è°ƒç”¨ä¿ç•™ï¼Œéœ€è¦æ»¡è¶³æ¡ä»¶ï¼š
   - âœ… æ— å¼•ç”¨å‚æ•°ï¼ˆé”®åŸºäºå€¼ï¼‰
   - âœ… æˆ–è€…ï¼šæœ‰å¼•ç”¨å‚æ•° + ä½¿ç”¨ `key=val`ï¼ˆé”®åŸºäºå€¼ï¼‰
   - âŒ ä¸èƒ½ç”¨ `key=ptr` æˆ– `key=ref`ï¼ˆé”®åŒ…å«åœ°å€ï¼Œä¼šè‡ªåŠ¨æ¸…é™¤ï¼‰

### ä½¿ç”¨æŠ€å·§

6. **å•æ¬¡é—®é¢˜æ±‚è§£ç”¨ `solve!`**ï¼šè‡ªåŠ¨æ¸…ç†ï¼Œæ¨èç”¨äº OJã€ç®—æ³•ç«èµ›
7. **Web æœåŠ¡ã€é…ç½®è§£æç­‰ç”¨ `lifetime=program`**ï¼šé•¿æœŸå¤ç”¨
8. **é€’å½’ä¼ é€’ç›¸åŒå¼•ç”¨ç”¨ `ptr`**ï¼šæœ€å¿«
9. **é¿å…å‰¯ä½œç”¨**ï¼šåªåœ¨çº¯å‡½æ•°ä¸Šä½¿ç”¨
10. **ç›‘æ§å†…å­˜**ï¼šå‚æ•°èŒƒå›´å¤§æ—¶ä½¿ç”¨ `solve!` æˆ–æ‰‹åŠ¨ `_clear()`

### èŒƒå›´å®é€‰æ‹©

11. **ç®€å•èšåˆç”¨ `min!/max!/sum!`**ï¼šæœ€ç®€æ´
12. **è‡ªå®šä¹‰æ“ä½œç”¨ `reduce!`**ï¼šçµæ´»
13. **éœ€è¦åˆå§‹å€¼ç”¨ `fold!`**ï¼šæœ€å¼ºå¤§ï¼Œå¯å¤„ç†ç©ºåºåˆ—å’Œç±»å‹è½¬æ¢

## æ›´æ–°æ—¥å¿—

### v0.1.15 (æœ€æ–°)
- âœ¨ **æ–°å¢ `sum!` ç©ºè¿­ä»£å™¨å¤„ç†**ï¼šç©ºè¿­ä»£å™¨è¿”å› 0ï¼ˆåŠ æ³•çš„å•ä½å…ƒï¼‰
  - æ”¯æŒæ‰€æœ‰æ•°å€¼ç±»å‹ï¼šæ•´æ•°ã€æµ®ç‚¹æ•°
  - æ•°å­¦ä¸Šåˆç†ï¼šç©ºé›†çš„å’Œ = 0
  - ä¸ `min!`ã€`max!` çš„è¾¹ç•Œå€¼å¤„ç†ä¿æŒä¸€è‡´
- ğŸ”§ **ç»Ÿä¸€ç©ºå¤„ç†é€»è¾‘**ï¼šé¿å… panicï¼Œæä¾›é»˜è®¤å€¼
- ğŸ“ **æ›´æ–°æ–‡æ¡£**ï¼šæ·»åŠ  `sum!` ç©ºè¿­ä»£å™¨è¯´æ˜å’Œç¤ºä¾‹

### v0.1.14
- ğŸ› **ä¿®å¤ `lifetime=program` é€»è¾‘**ï¼šä¿®æ­£äº†ç¼“å­˜ä¿ç•™/æ¸…é™¤çš„åˆ¤æ–­æ¡ä»¶
  - æ­£ç¡®è¡Œä¸ºï¼šé”®ä¸åŒ…å«åœ°å€æ—¶ä¿ç•™ç¼“å­˜ï¼Œé”®åŒ…å«åœ°å€æ—¶æ¸…é™¤ç¼“å­˜
  - æ— å¼•ç”¨å‚æ•° æˆ– `key=val`ï¼šä¿ç•™ç¼“å­˜ âœ“
  - æœ‰å¼•ç”¨å‚æ•° + (`key=ptr` æˆ– `key=ref`)ï¼šæ¸…é™¤ç¼“å­˜ âœ“ï¼ˆé¿å…å†…å­˜æµªè´¹ï¼‰
- ğŸ“ **æ›´æ–°æ–‡æ¡£**ï¼šåŒæ­¥ä¿®æ­£æ‰€æœ‰å…³äº `lifetime` å‚æ•°çš„è¯´æ˜å’Œç¤ºä¾‹

### v0.1.13
- âœ… **ä¿®å¤ä¸¤å‚æ•°è¯­æ³•**ï¼š`min!(1, 2)` ç°åœ¨å¯ä»¥æ­£å¸¸å·¥ä½œ
- âœ… **æ–°å¢ `lifetime` å‚æ•°**ï¼šç²¾ç¡®æ§åˆ¶ç¼“å­˜ç”Ÿå‘½å‘¨æœŸ
  - `lifetime=problem`ï¼ˆé»˜è®¤ï¼‰ï¼šè°ƒç”¨åæ¸…é™¤ç¼“å­˜
  - `lifetime=program`ï¼šä¿ç•™ç¼“å­˜ï¼ˆä»…åœ¨é”®ä¸åŒ…å«åœ°å€æ—¶æœ‰æ•ˆï¼‰
- âœ… **æ™ºèƒ½æ¸…é™¤é€»è¾‘**ï¼š`lifetime=program` ä¼šè‡ªåŠ¨æ£€æµ‹é”®æ˜¯å¦åŒ…å«åœ°å€ä¿¡æ¯
- âœ… **æ–°å¢ 50+ ç»¼åˆæµ‹è¯•**ï¼šfoldã€lifetimeã€ä¸¤å‚æ•°è¯­æ³•å…¨é¢æµ‹è¯•

### v0.1.11
- âœ… `solve!` å®ï¼šè‡ªåŠ¨æ¸…ç†ç¼“å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼ï¼ˆåŸå `start!`ï¼‰
- âœ… é»˜è®¤é”®æ¨¡å¼æ”¹ä¸º `ptr`ï¼ˆæ€§èƒ½æœ€ä½³ï¼‰
- âœ… `ref` æ¨¡å¼æ·»åŠ é•¿åº¦æ¯”è¾ƒï¼Œä¿®å¤åˆ‡ç‰‡ç¼“å­˜é”™è¯¯

### v0.1.10
- âœ… ä¸‰å±‚è®°å¿†åŒ–ç»“æ„ï¼Œæ™ºèƒ½ç¼“å­˜ç®¡ç†
- âœ… ç”Ÿæˆ `_start()` å’Œ `_clear()` è¾…åŠ©å‡½æ•°

### v0.1.8
- âœ… `key=ref` å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œä¸éœ€è¦ `r#ref`
- âœ… å‚æ•°éªŒè¯ï¼šæ— æ•ˆçš„å‚æ•°åæˆ–æ¨¡å¼ä¼šåœ¨ç¼–è¯‘æ—¶æŠ¥é”™

### v0.1.7
- âœ… `ref` æ¨¡å¼ï¼šå…ˆæ¯”åœ°å€ï¼Œè‹¥ç›¸ç­‰åˆ™å‘½ä¸­ï¼›å¦åˆ™å†æ¯”å†…å®¹
- âœ… å‚æ•°é‡å‘½åï¼š`thread_mode`â†’`thread`ï¼Œ`index_mode`â†’`key`
- âœ… é”®æ¨¡å¼é‡å‘½åï¼š`light`â†’`ptr`ï¼Œ`normal`â†’`ref`ï¼Œ`heavy`â†’`val`
- âœ… çº¿ç¨‹æ¨¡å¼é‡å‘½åï¼š`local`â†’`single`
- âœ… `ptr` æ¨¡å¼æ”¹è¿›ï¼šä½¿ç”¨ (åœ°å€, é•¿åº¦) ä½œä¸ºé”®
- âœ… `min!`/`max!` ç©ºè¿­ä»£å™¨è¿”å›è¾¹ç•Œå€¼

## è®¸å¯è¯

MIT æˆ– Apache-2.0 åŒè®¸å¯è¯ã€‚
